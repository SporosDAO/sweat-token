/* tslint:disable */
/* eslint-disable */
/**
 * Sweat Token
 * Sweat Token API description
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface ContactHandle
 */
export interface ContactHandle {
  /**
   *
   * @type {object}
   * @memberof ContactHandle
   */
  type: object
  /**
   *
   * @type {string}
   * @memberof ContactHandle
   */
  value: string
}
/**
 *
 * @export
 * @interface CreateDaoDto
 */
export interface CreateDaoDto {
  /**
   *
   * @type {string}
   * @memberof CreateDaoDto
   */
  daoId: string
  /**
   *
   * @type {string}
   * @memberof CreateDaoDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateDaoDto
   */
  mission: string
  /**
   *
   * @type {string}
   * @memberof CreateDaoDto
   */
  website: string
  /**
   *
   * @type {string}
   * @memberof CreateDaoDto
   */
  logo: string
  /**
   *
   * @type {string}
   * @memberof CreateDaoDto
   */
  kaliAddress: string
  /**
   *
   * @type {boolean}
   * @memberof CreateDaoDto
   */
  isPrivate: boolean
  /**
   *
   * @type {string}
   * @memberof CreateDaoDto
   */
  created: string
  /**
   *
   * @type {string}
   * @memberof CreateDaoDto
   */
  createdBy: string
}
/**
 *
 * @export
 * @interface CreateMemberDto
 */
export interface CreateMemberDto {
  /**
   *
   * @type {string}
   * @memberof CreateMemberDto
   */
  userId: string
  /**
   *
   * @type {string}
   * @memberof CreateMemberDto
   */
  daoId: string
  /**
   *
   * @type {Array<string>}
   * @memberof CreateMemberDto
   */
  roles?: Array<CreateMemberDtoRolesEnum>
  /**
   *
   * @type {string}
   * @memberof CreateMemberDto
   */
  invitedBy: string
  /**
   *
   * @type {string}
   * @memberof CreateMemberDto
   */
  memberId?: string
  /**
   *
   * @type {string}
   * @memberof CreateMemberDto
   */
  invitation?: string
  /**
   *
   * @type {string}
   * @memberof CreateMemberDto
   */
  status?: CreateMemberDtoStatusEnum
  /**
   *
   * @type {Array<string>}
   * @memberof CreateMemberDto
   */
  skills?: Array<CreateMemberDtoSkillsEnum>
}

export const CreateMemberDtoRolesEnum = {
  Admin: 'admin',
  Founder: 'founder',
  ProjectManager: 'projectManager',
  Mentor: 'mentor'
} as const

export type CreateMemberDtoRolesEnum = typeof CreateMemberDtoRolesEnum[keyof typeof CreateMemberDtoRolesEnum]
export const CreateMemberDtoStatusEnum = {
  Enabled: 'enabled',
  Disabled: 'disabled',
  Pending: 'pending',
  Accepted: 'accepted',
  Cancelled: 'cancelled'
} as const

export type CreateMemberDtoStatusEnum = typeof CreateMemberDtoStatusEnum[keyof typeof CreateMemberDtoStatusEnum]
export const CreateMemberDtoSkillsEnum = {
  Mentor: 'Mentor',
  SoftwareEngineer: 'Software Engineer',
  UxDesigner: 'UX/Designer',
  Legal: 'Legal',
  Operations: 'Operations',
  Finance: 'Finance',
  Policy: 'Policy'
} as const

export type CreateMemberDtoSkillsEnum = typeof CreateMemberDtoSkillsEnum[keyof typeof CreateMemberDtoSkillsEnum]

/**
 *
 * @export
 * @interface CreateProjectDto
 */
export interface CreateProjectDto {
  /**
   *
   * @type {string}
   * @memberof CreateProjectDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateProjectDto
   */
  deadline: string
  /**
   *
   * @type {number}
   * @memberof CreateProjectDto
   */
  budget: number
  /**
   *
   * @type {string}
   * @memberof CreateProjectDto
   */
  daoId: string
  /**
   *
   * @type {string}
   * @memberof CreateProjectDto
   */
  ownerId: string
}
/**
 *
 * @export
 * @interface CreateTaskDto
 */
export interface CreateTaskDto {
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  daoId: string
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  projectId: string
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  taskId: string
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  deadline: string
  /**
   *
   * @type {number}
   * @memberof CreateTaskDto
   */
  budget: number
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  ownerId: string
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  contributorId?: string
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  created: string
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  status: CreateTaskDtoStatusEnum
  /**
   *
   * @type {Array<string>}
   * @memberof CreateTaskDto
   */
  skills: Array<string>
  /**
   *
   * @type {Array<number>}
   * @memberof CreateTaskDto
   */
  bands?: Array<number>
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  type: CreateTaskDtoTypeEnum
  /**
   *
   * @type {string}
   * @memberof CreateTaskDto
   */
  period?: CreateTaskDtoPeriodEnum
}

export const CreateTaskDtoStatusEnum = {
  Open: 'open',
  Closed: 'closed',
  Cancelled: 'cancelled',
  Dispute: 'dispute'
} as const

export type CreateTaskDtoStatusEnum = typeof CreateTaskDtoStatusEnum[keyof typeof CreateTaskDtoStatusEnum]
export const CreateTaskDtoTypeEnum = {
  Ongoing: 'ongoing',
  Onetime: 'onetime'
} as const

export type CreateTaskDtoTypeEnum = typeof CreateTaskDtoTypeEnum[keyof typeof CreateTaskDtoTypeEnum]
export const CreateTaskDtoPeriodEnum = {
  Monthly: 'monthly',
  Weekly: 'weekly',
  Daily: 'daily'
} as const

export type CreateTaskDtoPeriodEnum = typeof CreateTaskDtoPeriodEnum[keyof typeof CreateTaskDtoPeriodEnum]

/**
 *
 * @export
 * @interface DaoDto
 */
export interface DaoDto {
  /**
   *
   * @type {string}
   * @memberof DaoDto
   */
  daoId: string
  /**
   *
   * @type {string}
   * @memberof DaoDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof DaoDto
   */
  mission: string
  /**
   *
   * @type {string}
   * @memberof DaoDto
   */
  website: string
  /**
   *
   * @type {string}
   * @memberof DaoDto
   */
  logo: string
  /**
   *
   * @type {string}
   * @memberof DaoDto
   */
  kaliAddress: string
  /**
   *
   * @type {boolean}
   * @memberof DaoDto
   */
  isPrivate: boolean
  /**
   *
   * @type {string}
   * @memberof DaoDto
   */
  created: string
  /**
   *
   * @type {string}
   * @memberof DaoDto
   */
  createdBy: string
}
/**
 *
 * @export
 * @interface ExtendedMemberDto
 */
export interface ExtendedMemberDto {
  /**
   *
   * @type {string}
   * @memberof ExtendedMemberDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ExtendedMemberDto
   */
  publicAddress: string
  /**
   *
   * @type {Array<ContactHandle>}
   * @memberof ExtendedMemberDto
   */
  contacts?: Array<ContactHandle>
  /**
   *
   * @type {string}
   * @memberof ExtendedMemberDto
   */
  memberId: string
  /**
   *
   * @type {string}
   * @memberof ExtendedMemberDto
   */
  userId: string
  /**
   *
   * @type {string}
   * @memberof ExtendedMemberDto
   */
  daoId: string
  /**
   *
   * @type {string}
   * @memberof ExtendedMemberDto
   */
  invitation: string
  /**
   *
   * @type {Array<string>}
   * @memberof ExtendedMemberDto
   */
  roles: Array<ExtendedMemberDtoRolesEnum>
  /**
   *
   * @type {string}
   * @memberof ExtendedMemberDto
   */
  status: ExtendedMemberDtoStatusEnum
  /**
   *
   * @type {Array<string>}
   * @memberof ExtendedMemberDto
   */
  skills?: Array<ExtendedMemberDtoSkillsEnum>
  /**
   *
   * @type {string}
   * @memberof ExtendedMemberDto
   */
  invitedBy: string
}

export const ExtendedMemberDtoRolesEnum = {
  Admin: 'admin',
  Founder: 'founder',
  ProjectManager: 'projectManager',
  Mentor: 'mentor'
} as const

export type ExtendedMemberDtoRolesEnum = typeof ExtendedMemberDtoRolesEnum[keyof typeof ExtendedMemberDtoRolesEnum]
export const ExtendedMemberDtoStatusEnum = {
  Enabled: 'enabled',
  Disabled: 'disabled',
  Pending: 'pending',
  Accepted: 'accepted',
  Cancelled: 'cancelled'
} as const

export type ExtendedMemberDtoStatusEnum = typeof ExtendedMemberDtoStatusEnum[keyof typeof ExtendedMemberDtoStatusEnum]
export const ExtendedMemberDtoSkillsEnum = {
  Mentor: 'Mentor',
  SoftwareEngineer: 'Software Engineer',
  UxDesigner: 'UX/Designer',
  Legal: 'Legal',
  Operations: 'Operations',
  Finance: 'Finance',
  Policy: 'Policy'
} as const

export type ExtendedMemberDtoSkillsEnum = typeof ExtendedMemberDtoSkillsEnum[keyof typeof ExtendedMemberDtoSkillsEnum]

/**
 *
 * @export
 * @interface JwtTokenDto
 */
export interface JwtTokenDto {
  /**
   *
   * @type {string}
   * @memberof JwtTokenDto
   */
  token: string
}
/**
 *
 * @export
 * @interface MemberDto
 */
export interface MemberDto {
  /**
   *
   * @type {string}
   * @memberof MemberDto
   */
  memberId: string
  /**
   *
   * @type {string}
   * @memberof MemberDto
   */
  userId: string
  /**
   *
   * @type {string}
   * @memberof MemberDto
   */
  daoId: string
  /**
   *
   * @type {string}
   * @memberof MemberDto
   */
  invitation: string
  /**
   *
   * @type {Array<string>}
   * @memberof MemberDto
   */
  roles: Array<MemberDtoRolesEnum>
  /**
   *
   * @type {string}
   * @memberof MemberDto
   */
  status: MemberDtoStatusEnum
  /**
   *
   * @type {Array<string>}
   * @memberof MemberDto
   */
  skills?: Array<MemberDtoSkillsEnum>
  /**
   *
   * @type {string}
   * @memberof MemberDto
   */
  invitedBy: string
}

export const MemberDtoRolesEnum = {
  Admin: 'admin',
  Founder: 'founder',
  ProjectManager: 'projectManager',
  Mentor: 'mentor'
} as const

export type MemberDtoRolesEnum = typeof MemberDtoRolesEnum[keyof typeof MemberDtoRolesEnum]
export const MemberDtoStatusEnum = {
  Enabled: 'enabled',
  Disabled: 'disabled',
  Pending: 'pending',
  Accepted: 'accepted',
  Cancelled: 'cancelled'
} as const

export type MemberDtoStatusEnum = typeof MemberDtoStatusEnum[keyof typeof MemberDtoStatusEnum]
export const MemberDtoSkillsEnum = {
  Mentor: 'Mentor',
  SoftwareEngineer: 'Software Engineer',
  UxDesigner: 'UX/Designer',
  Legal: 'Legal',
  Operations: 'Operations',
  Finance: 'Finance',
  Policy: 'Policy'
} as const

export type MemberDtoSkillsEnum = typeof MemberDtoSkillsEnum[keyof typeof MemberDtoSkillsEnum]

/**
 *
 * @export
 * @interface MemberInviteDto
 */
export interface MemberInviteDto {
  /**
   *
   * @type {string}
   * @memberof MemberInviteDto
   */
  daoId: string
  /**
   *
   * @type {string}
   * @memberof MemberInviteDto
   */
  invitedBy: string
  /**
   *
   * @type {Array<string>}
   * @memberof MemberInviteDto
   */
  projectId?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof MemberInviteDto
   */
  roles?: Array<MemberInviteDtoRolesEnum>
  /**
   *
   * @type {string}
   * @memberof MemberInviteDto
   */
  publicAddress: string
  /**
   *
   * @type {string}
   * @memberof MemberInviteDto
   */
  name?: string
}

export const MemberInviteDtoRolesEnum = {
  Admin: 'admin',
  Founder: 'founder',
  ProjectManager: 'projectManager',
  Mentor: 'mentor'
} as const

export type MemberInviteDtoRolesEnum = typeof MemberInviteDtoRolesEnum[keyof typeof MemberInviteDtoRolesEnum]

/**
 *
 * @export
 * @interface MemberQueryDto
 */
export interface MemberQueryDto {
  /**
   *
   * @type {string}
   * @memberof MemberQueryDto
   */
  daoId?: string
  /**
   *
   * @type {string}
   * @memberof MemberQueryDto
   */
  match?: string
  /**
   *
   * @type {string}
   * @memberof MemberQueryDto
   */
  userId?: string
  /**
   *
   * @type {string}
   * @memberof MemberQueryDto
   */
  memberId?: string
  /**
   *
   * @type {string}
   * @memberof MemberQueryDto
   */
  projectId?: string
  /**
   *
   * @type {string}
   * @memberof MemberQueryDto
   */
  dateField?: string
  /**
   *
   * @type {string}
   * @memberof MemberQueryDto
   */
  from?: string
  /**
   *
   * @type {string}
   * @memberof MemberQueryDto
   */
  to?: string
  /**
   *
   * @type {number}
   * @memberof MemberQueryDto
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof MemberQueryDto
   */
  skip?: number
  /**
   *
   * @type {string}
   * @memberof MemberQueryDto
   */
  status?: MemberQueryDtoStatusEnum
  /**
   *
   * @type {Array<string>}
   * @memberof MemberQueryDto
   */
  skills?: Array<MemberQueryDtoSkillsEnum>
}

export const MemberQueryDtoStatusEnum = {
  Enabled: 'enabled',
  Disabled: 'disabled',
  Pending: 'pending',
  Accepted: 'accepted',
  Cancelled: 'cancelled'
} as const

export type MemberQueryDtoStatusEnum = typeof MemberQueryDtoStatusEnum[keyof typeof MemberQueryDtoStatusEnum]
export const MemberQueryDtoSkillsEnum = {
  Mentor: 'Mentor',
  SoftwareEngineer: 'Software Engineer',
  UxDesigner: 'UX/Designer',
  Legal: 'Legal',
  Operations: 'Operations',
  Finance: 'Finance',
  Policy: 'Policy'
} as const

export type MemberQueryDtoSkillsEnum = typeof MemberQueryDtoSkillsEnum[keyof typeof MemberQueryDtoSkillsEnum]

/**
 *
 * @export
 * @interface NonceDto
 */
export interface NonceDto {
  /**
   *
   * @type {string}
   * @memberof NonceDto
   */
  nonce: string
  /**
   *
   * @type {string}
   * @memberof NonceDto
   */
  userId: string
  /**
   *
   * @type {string}
   * @memberof NonceDto
   */
  signature?: string
}
/**
 *
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  projectId: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  deadline: string
  /**
   *
   * @type {number}
   * @memberof ProjectDto
   */
  budget: number
  /**
   *
   * @type {number}
   * @memberof ProjectDto
   */
  budgetAllocation: number
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  proposalId: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  ownerId: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  daoId: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  created: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  status: ProjectDtoStatusEnum
}

export const ProjectDtoStatusEnum = {
  Open: 'open',
  Closed: 'closed',
  Disabled: 'disabled'
} as const

export type ProjectDtoStatusEnum = typeof ProjectDtoStatusEnum[keyof typeof ProjectDtoStatusEnum]

/**
 *
 * @export
 * @interface ProjectQueryDto
 */
export interface ProjectQueryDto {
  /**
   *
   * @type {string}
   * @memberof ProjectQueryDto
   */
  daoId?: string
  /**
   *
   * @type {string}
   * @memberof ProjectQueryDto
   */
  ownerId?: string
  /**
   *
   * @type {string}
   * @memberof ProjectQueryDto
   */
  dateField?: string
  /**
   *
   * @type {string}
   * @memberof ProjectQueryDto
   */
  from?: string
  /**
   *
   * @type {string}
   * @memberof ProjectQueryDto
   */
  to?: string
  /**
   *
   * @type {number}
   * @memberof ProjectQueryDto
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof ProjectQueryDto
   */
  skip?: number
  /**
   *
   * @type {string}
   * @memberof ProjectQueryDto
   */
  status?: ProjectQueryDtoStatusEnum
}

export const ProjectQueryDtoStatusEnum = {
  Open: 'open',
  Closed: 'closed',
  Disabled: 'disabled'
} as const

export type ProjectQueryDtoStatusEnum = typeof ProjectQueryDtoStatusEnum[keyof typeof ProjectQueryDtoStatusEnum]

/**
 *
 * @export
 * @interface TaskDto
 */
export interface TaskDto {
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  daoId: string
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  projectId: string
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  taskId: string
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  deadline: string
  /**
   *
   * @type {number}
   * @memberof TaskDto
   */
  budget: number
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  ownerId: string
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  contributorId?: string
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  created: string
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  status: TaskDtoStatusEnum
  /**
   *
   * @type {Array<string>}
   * @memberof TaskDto
   */
  skills: Array<string>
  /**
   *
   * @type {Array<number>}
   * @memberof TaskDto
   */
  bands?: Array<number>
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  type: TaskDtoTypeEnum
  /**
   *
   * @type {string}
   * @memberof TaskDto
   */
  period?: TaskDtoPeriodEnum
}

export const TaskDtoStatusEnum = {
  Open: 'open',
  Closed: 'closed',
  Cancelled: 'cancelled',
  Dispute: 'dispute'
} as const

export type TaskDtoStatusEnum = typeof TaskDtoStatusEnum[keyof typeof TaskDtoStatusEnum]
export const TaskDtoTypeEnum = {
  Ongoing: 'ongoing',
  Onetime: 'onetime'
} as const

export type TaskDtoTypeEnum = typeof TaskDtoTypeEnum[keyof typeof TaskDtoTypeEnum]
export const TaskDtoPeriodEnum = {
  Monthly: 'monthly',
  Weekly: 'weekly',
  Daily: 'daily'
} as const

export type TaskDtoPeriodEnum = typeof TaskDtoPeriodEnum[keyof typeof TaskDtoPeriodEnum]

/**
 *
 * @export
 * @interface TaskQueryDto
 */
export interface TaskQueryDto {
  /**
   *
   * @type {string}
   * @memberof TaskQueryDto
   */
  daoId?: string
  /**
   *
   * @type {string}
   * @memberof TaskQueryDto
   */
  ownerId?: string
  /**
   *
   * @type {string}
   * @memberof TaskQueryDto
   */
  projectId?: string
  /**
   *
   * @type {string}
   * @memberof TaskQueryDto
   */
  dateField?: string
  /**
   *
   * @type {string}
   * @memberof TaskQueryDto
   */
  from?: string
  /**
   *
   * @type {string}
   * @memberof TaskQueryDto
   */
  to?: string
  /**
   *
   * @type {number}
   * @memberof TaskQueryDto
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof TaskQueryDto
   */
  skip?: number
  /**
   *
   * @type {string}
   * @memberof TaskQueryDto
   */
  status?: TaskQueryDtoStatusEnum
}

export const TaskQueryDtoStatusEnum = {
  Open: 'open',
  Closed: 'closed',
  Cancelled: 'cancelled',
  Dispute: 'dispute'
} as const

export type TaskQueryDtoStatusEnum = typeof TaskQueryDtoStatusEnum[keyof typeof TaskQueryDtoStatusEnum]

/**
 *
 * @export
 * @interface UpdateTaskDto
 */
export interface UpdateTaskDto {
  /**
   *
   * @type {string}
   * @memberof UpdateTaskDto
   */
  taskId?: string
  /**
   *
   * @type {string}
   * @memberof UpdateTaskDto
   */
  contributorId?: string
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateTaskDto
   */
  skills?: Array<string>
  /**
   *
   * @type {string}
   * @memberof UpdateTaskDto
   */
  status?: UpdateTaskDtoStatusEnum
}

export const UpdateTaskDtoStatusEnum = {
  Open: 'open',
  Closed: 'closed',
  Cancelled: 'cancelled',
  Dispute: 'dispute'
} as const

export type UpdateTaskDtoStatusEnum = typeof UpdateTaskDtoStatusEnum[keyof typeof UpdateTaskDtoStatusEnum]

/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
  /**
   *
   * @type {Array<string>}
   * @memberof UserDto
   */
  roles?: Array<string>
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  userId: string
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  publicAddress: string
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  nonce: string
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  created: string
  /**
   *
   * @type {Array<ContactHandle>}
   * @memberof UserDto
   */
  contacts?: Array<ContactHandle>
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerGetProfile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/profile`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} publicAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerGetUser: async (publicAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'publicAddress' is not null or undefined
      assertParamExists('authControllerGetUser', 'publicAddress', publicAddress)
      const localVarPath = `/api/auth/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (publicAddress !== undefined) {
        localVarQueryParameter['publicAddress'] = publicAddress
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {NonceDto} nonceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerVerifySignature: async (
      nonceDto: NonceDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'nonceDto' is not null or undefined
      assertParamExists('authControllerVerifySignature', 'nonceDto', nonceDto)
      const localVarPath = `/api/auth/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(nonceDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerGetProfile(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} publicAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerGetUser(
      publicAddress: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetUser(publicAddress, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {NonceDto} nonceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerVerifySignature(
      nonceDto: NonceDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtTokenDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifySignature(nonceDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerGetProfile(options?: any): AxiosPromise<UserDto> {
      return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} publicAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerGetUser(publicAddress: string, options?: any): AxiosPromise<NonceDto> {
      return localVarFp.authControllerGetUser(publicAddress, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {NonceDto} nonceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerVerifySignature(nonceDto: NonceDto, options?: any): AxiosPromise<JwtTokenDto> {
      return localVarFp.authControllerVerifySignature(nonceDto, options).then((request) => request(axios, basePath))
    }
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerGetProfile(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerGetProfile(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} publicAddress
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerGetUser(publicAddress: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerGetUser(publicAddress, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {NonceDto} nonceDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerVerifySignature(nonceDto: NonceDto, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerVerifySignature(nonceDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DaoApi - axios parameter creator
 * @export
 */
export const DaoApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {CreateDaoDto} createDaoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerCreate: async (createDaoDto: CreateDaoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createDaoDto' is not null or undefined
      assertParamExists('daoControllerCreate', 'createDaoDto', createDaoDto)
      const localVarPath = `/api/dao`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createDaoDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerDelete: async (daoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('daoControllerDelete', 'daoId', daoId)
      const localVarPath = `/api/dao/{daoId}`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/dao`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerRead: async (daoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('daoControllerRead', 'daoId', daoId)
      const localVarPath = `/api/dao/{daoId}`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {CreateDaoDto} createDaoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerUpdate: async (
      daoId: string,
      createDaoDto: CreateDaoDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('daoControllerUpdate', 'daoId', daoId)
      // verify required parameter 'createDaoDto' is not null or undefined
      assertParamExists('daoControllerUpdate', 'createDaoDto', createDaoDto)
      const localVarPath = `/api/dao/{daoId}`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createDaoDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * DaoApi - functional programming interface
 * @export
 */
export const DaoApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DaoApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {CreateDaoDto} createDaoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async daoControllerCreate(
      createDaoDto: CreateDaoDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DaoDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.daoControllerCreate(createDaoDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async daoControllerDelete(
      daoId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.daoControllerDelete(daoId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async daoControllerList(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DaoDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.daoControllerList(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async daoControllerRead(
      daoId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DaoDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.daoControllerRead(daoId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {CreateDaoDto} createDaoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async daoControllerUpdate(
      daoId: string,
      createDaoDto: CreateDaoDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DaoDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.daoControllerUpdate(daoId, createDaoDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * DaoApi - factory interface
 * @export
 */
export const DaoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DaoApiFp(configuration)
  return {
    /**
     *
     * @param {CreateDaoDto} createDaoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerCreate(createDaoDto: CreateDaoDto, options?: any): AxiosPromise<DaoDto> {
      return localVarFp.daoControllerCreate(createDaoDto, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerDelete(daoId: string, options?: any): AxiosPromise<void> {
      return localVarFp.daoControllerDelete(daoId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerList(options?: any): AxiosPromise<Array<DaoDto>> {
      return localVarFp.daoControllerList(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerRead(daoId: string, options?: any): AxiosPromise<DaoDto> {
      return localVarFp.daoControllerRead(daoId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {CreateDaoDto} createDaoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    daoControllerUpdate(daoId: string, createDaoDto: CreateDaoDto, options?: any): AxiosPromise<DaoDto> {
      return localVarFp.daoControllerUpdate(daoId, createDaoDto, options).then((request) => request(axios, basePath))
    }
  }
}

/**
 * DaoApi - object-oriented interface
 * @export
 * @class DaoApi
 * @extends {BaseAPI}
 */
export class DaoApi extends BaseAPI {
  /**
   *
   * @param {CreateDaoDto} createDaoDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DaoApi
   */
  public daoControllerCreate(createDaoDto: CreateDaoDto, options?: AxiosRequestConfig) {
    return DaoApiFp(this.configuration)
      .daoControllerCreate(createDaoDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DaoApi
   */
  public daoControllerDelete(daoId: string, options?: AxiosRequestConfig) {
    return DaoApiFp(this.configuration)
      .daoControllerDelete(daoId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DaoApi
   */
  public daoControllerList(options?: AxiosRequestConfig) {
    return DaoApiFp(this.configuration)
      .daoControllerList(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DaoApi
   */
  public daoControllerRead(daoId: string, options?: AxiosRequestConfig) {
    return DaoApiFp(this.configuration)
      .daoControllerRead(daoId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {CreateDaoDto} createDaoDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DaoApi
   */
  public daoControllerUpdate(daoId: string, createDaoDto: CreateDaoDto, options?: AxiosRequestConfig) {
    return DaoApiFp(this.configuration)
      .daoControllerUpdate(daoId, createDaoDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * MemberApi - axios parameter creator
 * @export
 */
export const MemberApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} daoId
     * @param {CreateMemberDto} createMemberDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerCreate: async (
      daoId: string,
      createMemberDto: CreateMemberDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('memberControllerCreate', 'daoId', daoId)
      // verify required parameter 'createMemberDto' is not null or undefined
      assertParamExists('memberControllerCreate', 'createMemberDto', createMemberDto)
      const localVarPath = `/api/dao/{daoId}/member`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createMemberDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {string} memberId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerDelete: async (
      daoId: string,
      memberId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('memberControllerDelete', 'daoId', daoId)
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists('memberControllerDelete', 'memberId', memberId)
      const localVarPath = `/api/dao/{daoId}/member/{memberId}`
        .replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
        .replace(`{${'memberId'}}`, encodeURIComponent(String(memberId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {MemberQueryDto} memberQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerFind: async (
      daoId: string,
      memberQueryDto: MemberQueryDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('memberControllerFind', 'daoId', daoId)
      // verify required parameter 'memberQueryDto' is not null or undefined
      assertParamExists('memberControllerFind', 'memberQueryDto', memberQueryDto)
      const localVarPath = `/api/dao/{daoId}/member/find`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(memberQueryDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {MemberInviteDto} memberInviteDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerInvite: async (
      daoId: string,
      memberInviteDto: MemberInviteDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('memberControllerInvite', 'daoId', daoId)
      // verify required parameter 'memberInviteDto' is not null or undefined
      assertParamExists('memberControllerInvite', 'memberInviteDto', memberInviteDto)
      const localVarPath = `/api/dao/{daoId}/member/invite`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(memberInviteDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {MemberQueryDto} memberQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerList: async (
      daoId: string,
      memberQueryDto: MemberQueryDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('memberControllerList', 'daoId', daoId)
      // verify required parameter 'memberQueryDto' is not null or undefined
      assertParamExists('memberControllerList', 'memberQueryDto', memberQueryDto)
      const localVarPath = `/api/dao/{daoId}/member/list`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(memberQueryDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {string} memberId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerRead: async (
      daoId: string,
      memberId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('memberControllerRead', 'daoId', daoId)
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists('memberControllerRead', 'memberId', memberId)
      const localVarPath = `/api/dao/{daoId}/member/{memberId}`
        .replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
        .replace(`{${'memberId'}}`, encodeURIComponent(String(memberId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {string} memberId
     * @param {MemberDto} memberDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerUpdate: async (
      daoId: string,
      memberId: string,
      memberDto: MemberDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('memberControllerUpdate', 'daoId', daoId)
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists('memberControllerUpdate', 'memberId', memberId)
      // verify required parameter 'memberDto' is not null or undefined
      assertParamExists('memberControllerUpdate', 'memberDto', memberDto)
      const localVarPath = `/api/dao/{daoId}/member/{memberId}`
        .replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
        .replace(`{${'memberId'}}`, encodeURIComponent(String(memberId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(memberDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * MemberApi - functional programming interface
 * @export
 */
export const MemberApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MemberApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} daoId
     * @param {CreateMemberDto} createMemberDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async memberControllerCreate(
      daoId: string,
      createMemberDto: CreateMemberDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.memberControllerCreate(daoId, createMemberDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {string} memberId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async memberControllerDelete(
      daoId: string,
      memberId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.memberControllerDelete(daoId, memberId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {MemberQueryDto} memberQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async memberControllerFind(
      daoId: string,
      memberQueryDto: MemberQueryDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.memberControllerFind(daoId, memberQueryDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {MemberInviteDto} memberInviteDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async memberControllerInvite(
      daoId: string,
      memberInviteDto: MemberInviteDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.memberControllerInvite(daoId, memberInviteDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {MemberQueryDto} memberQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async memberControllerList(
      daoId: string,
      memberQueryDto: MemberQueryDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExtendedMemberDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.memberControllerList(daoId, memberQueryDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {string} memberId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async memberControllerRead(
      daoId: string,
      memberId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.memberControllerRead(daoId, memberId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {string} memberId
     * @param {MemberDto} memberDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async memberControllerUpdate(
      daoId: string,
      memberId: string,
      memberDto: MemberDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.memberControllerUpdate(
        daoId,
        memberId,
        memberDto,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * MemberApi - factory interface
 * @export
 */
export const MemberApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = MemberApiFp(configuration)
  return {
    /**
     *
     * @param {string} daoId
     * @param {CreateMemberDto} createMemberDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerCreate(daoId: string, createMemberDto: CreateMemberDto, options?: any): AxiosPromise<MemberDto> {
      return localVarFp
        .memberControllerCreate(daoId, createMemberDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {string} memberId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerDelete(daoId: string, memberId: string, options?: any): AxiosPromise<void> {
      return localVarFp.memberControllerDelete(daoId, memberId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {MemberQueryDto} memberQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerFind(daoId: string, memberQueryDto: MemberQueryDto, options?: any): AxiosPromise<Array<MemberDto>> {
      return localVarFp.memberControllerFind(daoId, memberQueryDto, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {MemberInviteDto} memberInviteDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerInvite(daoId: string, memberInviteDto: MemberInviteDto, options?: any): AxiosPromise<MemberDto> {
      return localVarFp
        .memberControllerInvite(daoId, memberInviteDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {MemberQueryDto} memberQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerList(
      daoId: string,
      memberQueryDto: MemberQueryDto,
      options?: any
    ): AxiosPromise<Array<ExtendedMemberDto>> {
      return localVarFp.memberControllerList(daoId, memberQueryDto, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {string} memberId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerRead(daoId: string, memberId: string, options?: any): AxiosPromise<MemberDto> {
      return localVarFp.memberControllerRead(daoId, memberId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {string} memberId
     * @param {MemberDto} memberDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    memberControllerUpdate(
      daoId: string,
      memberId: string,
      memberDto: MemberDto,
      options?: any
    ): AxiosPromise<MemberDto> {
      return localVarFp
        .memberControllerUpdate(daoId, memberId, memberDto, options)
        .then((request) => request(axios, basePath))
    }
  }
}

/**
 * MemberApi - object-oriented interface
 * @export
 * @class MemberApi
 * @extends {BaseAPI}
 */
export class MemberApi extends BaseAPI {
  /**
   *
   * @param {string} daoId
   * @param {CreateMemberDto} createMemberDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberApi
   */
  public memberControllerCreate(daoId: string, createMemberDto: CreateMemberDto, options?: AxiosRequestConfig) {
    return MemberApiFp(this.configuration)
      .memberControllerCreate(daoId, createMemberDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {string} memberId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberApi
   */
  public memberControllerDelete(daoId: string, memberId: string, options?: AxiosRequestConfig) {
    return MemberApiFp(this.configuration)
      .memberControllerDelete(daoId, memberId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {MemberQueryDto} memberQueryDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberApi
   */
  public memberControllerFind(daoId: string, memberQueryDto: MemberQueryDto, options?: AxiosRequestConfig) {
    return MemberApiFp(this.configuration)
      .memberControllerFind(daoId, memberQueryDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {MemberInviteDto} memberInviteDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberApi
   */
  public memberControllerInvite(daoId: string, memberInviteDto: MemberInviteDto, options?: AxiosRequestConfig) {
    return MemberApiFp(this.configuration)
      .memberControllerInvite(daoId, memberInviteDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {MemberQueryDto} memberQueryDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberApi
   */
  public memberControllerList(daoId: string, memberQueryDto: MemberQueryDto, options?: AxiosRequestConfig) {
    return MemberApiFp(this.configuration)
      .memberControllerList(daoId, memberQueryDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {string} memberId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberApi
   */
  public memberControllerRead(daoId: string, memberId: string, options?: AxiosRequestConfig) {
    return MemberApiFp(this.configuration)
      .memberControllerRead(daoId, memberId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {string} memberId
   * @param {MemberDto} memberDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberApi
   */
  public memberControllerUpdate(daoId: string, memberId: string, memberDto: MemberDto, options?: AxiosRequestConfig) {
    return MemberApiFp(this.configuration)
      .memberControllerUpdate(daoId, memberId, memberDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} daoId
     * @param {CreateProjectDto} createProjectDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerCreate: async (
      daoId: string,
      createProjectDto: CreateProjectDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('projectControllerCreate', 'daoId', daoId)
      // verify required parameter 'createProjectDto' is not null or undefined
      assertParamExists('projectControllerCreate', 'createProjectDto', createProjectDto)
      const localVarPath = `/api/dao/{daoId}/project`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createProjectDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerDelete: async (
      daoId: string,
      projectId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('projectControllerDelete', 'daoId', daoId)
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('projectControllerDelete', 'projectId', projectId)
      const localVarPath = `/api/dao/{daoId}/project/{projectId}`
        .replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
        .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {ProjectQueryDto} projectQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerFind: async (
      daoId: string,
      projectQueryDto: ProjectQueryDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('projectControllerFind', 'daoId', daoId)
      // verify required parameter 'projectQueryDto' is not null or undefined
      assertParamExists('projectControllerFind', 'projectQueryDto', projectQueryDto)
      const localVarPath = `/api/dao/{daoId}/project/find`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(projectQueryDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerRead: async (
      daoId: string,
      projectId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('projectControllerRead', 'daoId', daoId)
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('projectControllerRead', 'projectId', projectId)
      const localVarPath = `/api/dao/{daoId}/project/{projectId}`
        .replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
        .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {string} projectId
     * @param {ProjectDto} projectDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerUpdate: async (
      daoId: string,
      projectId: string,
      projectDto: ProjectDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('projectControllerUpdate', 'daoId', daoId)
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('projectControllerUpdate', 'projectId', projectId)
      // verify required parameter 'projectDto' is not null or undefined
      assertParamExists('projectControllerUpdate', 'projectDto', projectDto)
      const localVarPath = `/api/dao/{daoId}/project/{projectId}`
        .replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
        .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(projectDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} daoId
     * @param {CreateProjectDto} createProjectDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async projectControllerCreate(
      daoId: string,
      createProjectDto: CreateProjectDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreate(
        daoId,
        createProjectDto,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async projectControllerDelete(
      daoId: string,
      projectId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerDelete(daoId, projectId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {ProjectQueryDto} projectQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async projectControllerFind(
      daoId: string,
      projectQueryDto: ProjectQueryDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFind(daoId, projectQueryDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async projectControllerRead(
      daoId: string,
      projectId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerRead(daoId, projectId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {string} projectId
     * @param {ProjectDto} projectDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async projectControllerUpdate(
      daoId: string,
      projectId: string,
      projectDto: ProjectDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdate(
        daoId,
        projectId,
        projectDto,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ProjectApiFp(configuration)
  return {
    /**
     *
     * @param {string} daoId
     * @param {CreateProjectDto} createProjectDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerCreate(
      daoId: string,
      createProjectDto: CreateProjectDto,
      options?: any
    ): AxiosPromise<ProjectDto> {
      return localVarFp
        .projectControllerCreate(daoId, createProjectDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerDelete(daoId: string, projectId: string, options?: any): AxiosPromise<void> {
      return localVarFp.projectControllerDelete(daoId, projectId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {ProjectQueryDto} projectQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerFind(
      daoId: string,
      projectQueryDto: ProjectQueryDto,
      options?: any
    ): AxiosPromise<Array<ProjectDto>> {
      return localVarFp
        .projectControllerFind(daoId, projectQueryDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerRead(daoId: string, projectId: string, options?: any): AxiosPromise<ProjectDto> {
      return localVarFp.projectControllerRead(daoId, projectId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {string} projectId
     * @param {ProjectDto} projectDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectControllerUpdate(
      daoId: string,
      projectId: string,
      projectDto: ProjectDto,
      options?: any
    ): AxiosPromise<ProjectDto> {
      return localVarFp
        .projectControllerUpdate(daoId, projectId, projectDto, options)
        .then((request) => request(axios, basePath))
    }
  }
}

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
  /**
   *
   * @param {string} daoId
   * @param {CreateProjectDto} createProjectDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public projectControllerCreate(daoId: string, createProjectDto: CreateProjectDto, options?: AxiosRequestConfig) {
    return ProjectApiFp(this.configuration)
      .projectControllerCreate(daoId, createProjectDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {string} projectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public projectControllerDelete(daoId: string, projectId: string, options?: AxiosRequestConfig) {
    return ProjectApiFp(this.configuration)
      .projectControllerDelete(daoId, projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {ProjectQueryDto} projectQueryDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public projectControllerFind(daoId: string, projectQueryDto: ProjectQueryDto, options?: AxiosRequestConfig) {
    return ProjectApiFp(this.configuration)
      .projectControllerFind(daoId, projectQueryDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {string} projectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public projectControllerRead(daoId: string, projectId: string, options?: AxiosRequestConfig) {
    return ProjectApiFp(this.configuration)
      .projectControllerRead(daoId, projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {string} projectId
   * @param {ProjectDto} projectDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public projectControllerUpdate(
    daoId: string,
    projectId: string,
    projectDto: ProjectDto,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .projectControllerUpdate(daoId, projectId, projectDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} daoId
     * @param {CreateTaskDto} createTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerCreate: async (
      daoId: string,
      createTaskDto: CreateTaskDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('taskControllerCreate', 'daoId', daoId)
      // verify required parameter 'createTaskDto' is not null or undefined
      assertParamExists('taskControllerCreate', 'createTaskDto', createTaskDto)
      const localVarPath = `/api/dao/{daoId}/task`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerDelete: async (
      daoId: string,
      taskId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('taskControllerDelete', 'daoId', daoId)
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('taskControllerDelete', 'taskId', taskId)
      const localVarPath = `/api/dao/{daoId}/task/{taskId}`
        .replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
        .replace(`{${'taskId'}}`, encodeURIComponent(String(taskId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {TaskQueryDto} taskQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerFind: async (
      daoId: string,
      taskQueryDto: TaskQueryDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('taskControllerFind', 'daoId', daoId)
      // verify required parameter 'taskQueryDto' is not null or undefined
      assertParamExists('taskControllerFind', 'taskQueryDto', taskQueryDto)
      const localVarPath = `/api/dao/{daoId}/task/find`.replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(taskQueryDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerRead: async (
      daoId: string,
      taskId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('taskControllerRead', 'daoId', daoId)
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('taskControllerRead', 'taskId', taskId)
      const localVarPath = `/api/dao/{daoId}/task/{taskId}`
        .replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
        .replace(`{${'taskId'}}`, encodeURIComponent(String(taskId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} daoId
     * @param {string} taskId
     * @param {UpdateTaskDto} updateTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerUpdate: async (
      daoId: string,
      taskId: string,
      updateTaskDto: UpdateTaskDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'daoId' is not null or undefined
      assertParamExists('taskControllerUpdate', 'daoId', daoId)
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('taskControllerUpdate', 'taskId', taskId)
      // verify required parameter 'updateTaskDto' is not null or undefined
      assertParamExists('taskControllerUpdate', 'updateTaskDto', updateTaskDto)
      const localVarPath = `/api/dao/{daoId}/task/{taskId}`
        .replace(`{${'daoId'}}`, encodeURIComponent(String(daoId)))
        .replace(`{${'taskId'}}`, encodeURIComponent(String(taskId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(updateTaskDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} daoId
     * @param {CreateTaskDto} createTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taskControllerCreate(
      daoId: string,
      createTaskDto: CreateTaskDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerCreate(daoId, createTaskDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taskControllerDelete(
      daoId: string,
      taskId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerDelete(daoId, taskId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {TaskQueryDto} taskQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taskControllerFind(
      daoId: string,
      taskQueryDto: TaskQueryDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerFind(daoId, taskQueryDto, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taskControllerRead(
      daoId: string,
      taskId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerRead(daoId, taskId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} daoId
     * @param {string} taskId
     * @param {UpdateTaskDto} updateTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taskControllerUpdate(
      daoId: string,
      taskId: string,
      updateTaskDto: UpdateTaskDto,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerUpdate(
        daoId,
        taskId,
        updateTaskDto,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TaskApiFp(configuration)
  return {
    /**
     *
     * @param {string} daoId
     * @param {CreateTaskDto} createTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerCreate(daoId: string, createTaskDto: CreateTaskDto, options?: any): AxiosPromise<TaskDto> {
      return localVarFp.taskControllerCreate(daoId, createTaskDto, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerDelete(daoId: string, taskId: string, options?: any): AxiosPromise<void> {
      return localVarFp.taskControllerDelete(daoId, taskId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {TaskQueryDto} taskQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerFind(daoId: string, taskQueryDto: TaskQueryDto, options?: any): AxiosPromise<Array<TaskDto>> {
      return localVarFp.taskControllerFind(daoId, taskQueryDto, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerRead(daoId: string, taskId: string, options?: any): AxiosPromise<TaskDto> {
      return localVarFp.taskControllerRead(daoId, taskId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} daoId
     * @param {string} taskId
     * @param {UpdateTaskDto} updateTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskControllerUpdate(
      daoId: string,
      taskId: string,
      updateTaskDto: UpdateTaskDto,
      options?: any
    ): AxiosPromise<TaskDto> {
      return localVarFp
        .taskControllerUpdate(daoId, taskId, updateTaskDto, options)
        .then((request) => request(axios, basePath))
    }
  }
}

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
  /**
   *
   * @param {string} daoId
   * @param {CreateTaskDto} createTaskDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public taskControllerCreate(daoId: string, createTaskDto: CreateTaskDto, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .taskControllerCreate(daoId, createTaskDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {string} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public taskControllerDelete(daoId: string, taskId: string, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .taskControllerDelete(daoId, taskId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {TaskQueryDto} taskQueryDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public taskControllerFind(daoId: string, taskQueryDto: TaskQueryDto, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .taskControllerFind(daoId, taskQueryDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {string} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public taskControllerRead(daoId: string, taskId: string, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .taskControllerRead(daoId, taskId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} daoId
   * @param {string} taskId
   * @param {UpdateTaskDto} updateTaskDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public taskControllerUpdate(
    daoId: string,
    taskId: string,
    updateTaskDto: UpdateTaskDto,
    options?: AxiosRequestConfig
  ) {
    return TaskApiFp(this.configuration)
      .taskControllerUpdate(daoId, taskId, updateTaskDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
